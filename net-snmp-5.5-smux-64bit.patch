1069046 - snmpd returns truncated value for Counter64 taken from smuxpeer

Several upstream patches are below.

commit 20e4b37932a9e9cc56b360a236e9d8180793a297
Author: Magnus Fromreide <magfr@lysator.liu.se>
Date:   Wed Nov 27 00:54:58 2013 +0100

    CHANGES: snmplib: Correct the type check for opaque variables when decoding counter64 values.
    
    Thanks to rkj@softhome.net for reporting this issue.

diff --git a/snmplib/asn1.c b/snmplib/asn1.c
index d5d6280..f9632ef 100644
--- a/snmplib/asn1.c
+++ b/snmplib/asn1.c
@@ -1834,7 +1834,7 @@ asn_parse_unsigned_int64(u_char * data,
     *type = *bufp++;
     if (*type != ASN_COUNTER64
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
-            && *type != ASN_OPAQUE_COUNTER64 && *type != ASN_OPAQUE_U64
+            && *type != ASN_OPAQUE
 #endif
             ) {
         _asn_type_err(errpre, *type);

commit 6e76cbbb2a0783f22f58fb7d323e9f7217cc604a
Author: Magnus Fromreide <magfr@lysator.liu.se>
Date:   Wed Nov 27 01:01:04 2013 +0100

    CHANGES: snmplib: Avoid failure to trigger sign extension due to overlong types
    
    In asn_realloc_rbuild_signed_int64 the algorithm assumes that shifting
    values greater than 0x7fffffff right is an arithmetic shift that will
    shift in 1's. On hosts where long is more than 32 bits the use of long
    for 'low' and 'high' makes this assumption false.
    
    Thanks to rkj@softhome.net for reporting this issue.

diff --git a/snmplib/asn1.c b/snmplib/asn1.c
index fbc8390..2346e6c 100644
--- a/snmplib/asn1.c
+++ b/snmplib/asn1.c
@@ -3402,9 +3402,10 @@ asn_realloc_rbuild_signed_int64(u_char ** pkt, size_t * pkt_len,
     /*
      * ASN.1 integer ::= 0x02 asnlength byte {byte}*
      */
-    register long low = cp->low, high = cp->high;
-    size_t          intsize, start_offset = *offset;
-    int             count, testvalue = (high & 0x80000000) ? -1 : 0;
+    register int32_t low = cp->low, high = cp->high;
+    size_t           intsize, start_offset = *offset;
+    int              count;
+    int32_t          testvalue = (high & 0x80000000) ? -1 : 0;
 
     if (countersize != sizeof(struct counter64)) {
         _asn_size_err("build uint64", countersize,

commit be9161d3a5898e863767f926613486126c2cbf67
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Jan 6 12:35:39 2012 +0100

    CHANGES: snmplib: Simplify implementation of functions manipulating 64-bit numbers.

diff --git a/snmplib/asn1.c b/snmplib/asn1.c
index 2fb5445..fbc8390 100644
--- a/snmplib/asn1.c
+++ b/snmplib/asn1.c
@@ -1504,13 +1504,8 @@ asn_build_objid(u_char * data,
      */
     for (i = 1, objid_val = first_objid_val, op = objid + 2;
          i < (int) objidlength; i++) {
-        if (i != 1) {
-            objid_val = *op++;
-#if SIZEOF_LONG != 4
-            if (objid_val > 0xffffffff) /* already logged warning above */
-                objid_val &= 0xffffffff;
-#endif
-        }
+        if (i != 1)
+            objid_val = (uint32_t)(*op++); /* already logged warning above */
         switch (objid_size[i]) {
         case 1:
             *data++ = (u_char) objid_val;
diff --git a/snmplib/int64.c b/snmplib/int64.c
index b766372..ea56673 100644
--- a/snmplib/int64.c
+++ b/snmplib/int64.c
@@ -1,9 +1,10 @@
-/** file: test.c - test of 64-bit integer stuff
-*
-*
-* 21-jan-1998: David Perkins <dperkins@dsperkins.com>
-*
-*/
+/**
+ * @file int64.c
+ *
+ * @brief Functions for 64-bit integer computations.
+ *
+ * 21-jan-1998: David Perkins <dperkins@dsperkins.com>
+ */
 
 #include <net-snmp/net-snmp-config.h>
 #include <sys/types.h>
@@ -25,17 +26,13 @@
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/snmp_logging.h>
 
-#define TRUE 1
-#define FALSE 0
-
-/** divBy10 - divide an unsigned 64-bit integer by 10
-*
-* call with:
-*   u64 - number to be divided
-*   pu64Q - location to store quotient
-*   puR - location to store remainder
-*
-*/
+/**
+ * Divide an unsigned 64-bit integer by 10.
+ *
+ * @param[in]  u64   Number to be divided.
+ * @param[out] pu64Q Quotient.
+ * @param[out] puR   Remainder.
+ */
 void
 divBy10(U64 u64, U64 * pu64Q, unsigned int *puR)
 {
@@ -43,7 +40,6 @@ divBy10(U64 u64, U64 * pu64Q, unsigned int *puR)
     unsigned long   ulQ;
     unsigned long   ulR;
 
-
     /*
      * top 16 bits 
      */
@@ -79,18 +75,14 @@ divBy10(U64 u64, U64 * pu64Q, unsigned int *puR)
     pu64Q->low = pu64Q->low | ulQ;
 
     *puR = (unsigned int) (ulR);
+}
 
-
-}                               /* divBy10 */
-
-
-/** multBy10 - multiply an unsigned 64-bit integer by 10
-*
-* call with:
-*   u64 - number to be multiplied
-*   pu64P - location to store product
-*
-*/
+/**
+ * Multiply an unsigned 64-bit integer by 10.
+ *
+ * @param[in]  u64   Number to be multiplied.
+ * @param[out] pu64P Product.
+ */
 void
 multBy10(U64 u64, U64 * pu64P)
 {
@@ -98,7 +90,6 @@ multBy10(U64 u64, U64 * pu64P)
     unsigned long   ulP;
     unsigned long   ulK;
 
-
     /*
      * lower 16 bits 
      */
@@ -130,156 +121,119 @@ multBy10(U64 u64, U64 * pu64P)
     ulP = (ulT * 10) + ulK;
     ulK = ulP >> 16;
     pu64P->high = (ulP & 0x0ffff) << 16 | pu64P->high;
+}
 
-
-}                               /* multBy10 */
-
-
-/** incrByU16 - add an unsigned 16-bit int to an unsigned 64-bit integer
-*
-* call with:
-*   pu64 - number to be incremented
-*   u16 - amount to add
-*
-*/
+/**
+ * Add an unsigned 16-bit int to an unsigned 64-bit integer.
+ *
+ * @param[in,out] pu64 Number to be incremented.
+ * @param[in]     u16  Amount to add.
+ *
+ */
 void
 incrByU16(U64 * pu64, unsigned int u16)
 {
-    unsigned long   ulT1;
-    unsigned long   ulT2;
-    unsigned long   ulR;
-    unsigned long   ulK;
-
-
-    /*
-     * lower 16 bits 
-     */
-    ulT1 = pu64->low;
-    ulT2 = ulT1 & 0x0ffff;
-    ulR = ulT2 + u16;
-    ulK = ulR >> 16;
-    if (ulK == 0) {
-        pu64->low = ulT1 + u16;
-        return;
-    }
-
-    /*
-     * next 16 bits 
-     */
-    ulT2 = (ulT1 >> 16) & 0x0ffff;
-    ulR = ulT2 + 1;
-    ulK = ulR >> 16;
-    if (ulK == 0) {
-        pu64->low = ulT1 + u16;
-        return;
-    }
-
-    /*
-     * next 32 - ignore any overflow 
-     */
-    pu64->low = (ulT1 + u16) & 0x0FFFFFFFFL;
-    pu64->high++;
-#if SIZEOF_LONG != 4
-    pu64->high &= 0xffffffff;
-#endif
-}                               /* incrByV16 */
+    incrByU32(pu64, u16);
+}
 
+/**
+ * Add an unsigned 32-bit int to an unsigned 64-bit integer.
+ *
+ * @param[in,out] pu64 Number to be incremented.
+ * @param[in]     u32  Amount to add.
+ *
+ */
 void
 incrByU32(U64 * pu64, unsigned int u32)
 {
-    unsigned int    tmp;
+    uint32_t tmp;
+
     tmp = pu64->low;
-    pu64->low += u32;
-#if SIZEOF_LONG != 4
-    pu64->low &= 0xffffffff;
-#endif
-    if (pu64->low < tmp) {
-        pu64->high++;
-#if SIZEOF_LONG != 4
-        pu64->high &= 0xffffffff;
-#endif
-    }
+    pu64->low = (uint32_t)(tmp + u32);
+    if (pu64->low < tmp)
+        pu64->high = (uint32_t)(pu64->high + 1);
 }
 
 /**
- * pu64out = pu64one - pu64two 
+ * Subtract two 64-bit numbers.
+ *
+ * @param[in] pu64one Number to start from.
+ * @param[in] pu64two Amount to subtract.
+ * @param[out] pu64out pu64one - pu64two.
  */
 void
 u64Subtract(const U64 * pu64one, const U64 * pu64two, U64 * pu64out)
 {
-    if (pu64one->low < pu64two->low) {
-        pu64out->low = 0xffffffff - pu64two->low + pu64one->low + 1;
-        pu64out->high = pu64one->high - pu64two->high - 1;
-    } else {
-        pu64out->low = pu64one->low - pu64two->low;
-        pu64out->high = pu64one->high - pu64two->high;
-    }
+    int carry;
+
+    carry = pu64one->low < pu64two->low;
+    pu64out->low = (uint32_t)(pu64one->low - pu64two->low);
+    pu64out->high = (uint32_t)(pu64one->high - pu64two->high - carry);
 }
 
 /**
- * pu64out += pu64one
+ * Add two 64-bit numbers.
+ *
+ * @param[in] pu64one Amount to add.
+ * @param[in,out] pu64out pu64out += pu64one.
  */
 void
 u64Incr(U64 * pu64out, const U64 * pu64one)
 {
-    pu64out->high += pu64one->high;
-#if SIZEOF_LONG != 4
-    pu64out->high &= 0xffffffff;
-#endif
+    pu64out->high = (uint32_t)(pu64out->high + pu64one->high);
     incrByU32(pu64out, pu64one->low);
 }
 
 /**
- * pu64out += (pu64one - pu64two)
+ * Add the difference of two 64-bit numbers to a 64-bit counter.
+ *
+ * @param[in] pu64one
+ * @param[in] pu64two
+ * @param[out] pu64out pu64out += (pu64one - pu64two)
  */
 void
 u64UpdateCounter(U64 * pu64out, const U64 * pu64one, const U64 * pu64two)
 {
     U64 tmp;
+
     u64Subtract(pu64one, pu64two, &tmp);
     u64Incr(pu64out, &tmp);
 }
 
 /**
- * pu64one = pu64two 
+ * Copy a 64-bit number.
+ *
+ * @param[in] pu64two Number to be copied.
+ * @param[out] pu64one Where to store the copy - *pu64one = *pu64two.
  */
 void
 u64Copy(U64 * pu64one, const U64 * pu64two)
 {
-    pu64one->high = pu64two->high;
-    pu64one->low =  pu64two->low;
+    *pu64one = *pu64two;
 }
 
-/** zeroU64 - set an unsigned 64-bit number to zero
-*
-* call with:
-*   pu64 - number to be zero'ed
-*
-*/
+/**
+ * Set an unsigned 64-bit number to zero.
+ *
+ * @param[in] pu64 Number to be zeroed.
+ */
 void
 zeroU64(U64 * pu64)
 {
     pu64->low = 0;
     pu64->high = 0;
-}                               /* zeroU64 */
-
+}
 
-/** isZeroU64 - check if an unsigned 64-bit number is
-*
-* call with:
-*   pu64 - number to be zero'ed
-*
-*/
+/**
+ * Check if an unsigned 64-bit number is zero.
+ *
+ * @param[in] pu64 Number to be checked.
+ */
 int
 isZeroU64(const U64 * pu64)
 {
-
-    if ((pu64->low == 0) && (pu64->high == 0))
-        return (TRUE);
-    else
-        return (FALSE);
-
-}                               /* isZeroU64 */
+    return pu64->low == 0 && pu64->high == 0;
+}
 
 /**
  * check the old and new values of a counter64 for 32bit wrapping
@@ -290,7 +244,7 @@ isZeroU64(const U64 * pu64)
  * @param old_val
  * @param new_val
  *
- *@Note:
+ * @note
  * The old and new values must be be from within a time period
  * which would only allow the 32bit portion of the counter to
  * wrap once. i.e. if the 32bit portion of the counter could
@@ -329,16 +283,11 @@ netsnmp_c64_check_for_32bit_wrap(struct counter64 *old_val,
      */
     if (new_val->high == old_val->high) {
         DEBUGMSGTL(("c64:check_wrap", "32 bit wrap\n"));
-        if (adjust) {
-            ++new_val->high;
-#if SIZEOF_LONG != 4
-            new_val->high &= 0xffffffff;
-#endif
-        }
+        if (adjust)
+            new_val->high = (uint32_t)(new_val->high + 1);
         return 32;
     }
-    else if ((new_val->high == (old_val->high + 1)) ||
-             ((0 == new_val->high) && (0xffffffff == old_val->high))) {
+    else if (new_val->high == (uint32_t)(old_val->high + 1)) {
         DEBUGMSGTL(("c64:check_wrap", "64 bit wrap\n"));
         return 64;
     }
@@ -355,7 +304,7 @@ netsnmp_c64_check_for_32bit_wrap(struct counter64 *old_val,
  * @param need_wrap_check: pointer to integer indicating if wrap check is needed
  *                         flag may be cleared if 64 bit counter is detected
  *
- *@Note:
+ * @note
  * The old_prev_val and new_val values must be be from within a time
  * period which would only allow the 32bit portion of the counter to
  * wrap once. i.e. if the 32bit portion of the counter could
@@ -436,9 +385,11 @@ netsnmp_c64_check32_and_update(struct counter64 *prev_val, struct counter64 *new
     return 0;
 }
 
+/** Convert an unsigned 64-bit number to ASCII. */
 void
-printU64(char *buf,     /* char [I64CHARSZ+1]; */
-                         const U64 * pu64) {
+printU64(char *buf, /* char [I64CHARSZ+1]; */
+         const U64 * pu64)
+{
     U64             u64a;
     U64             u64b;
 
@@ -446,57 +397,37 @@ printU64(char *buf,     /* char [I64CHARSZ+1]; */
     unsigned int    u;
     int             j;
 
-    u64a.high = pu64->high;
-    u64a.low = pu64->low;
+    u64a = *pu64;
     aRes[I64CHARSZ] = 0;
     for (j = 0; j < I64CHARSZ; j++) {
         divBy10(u64a, &u64b, &u);
         aRes[(I64CHARSZ - 1) - j] = (char) ('0' + u);
-        u64a.high = u64b.high;
-        u64a.low = u64b.low;
+        u64a = u64b;
         if (isZeroU64(&u64a))
             break;
     }
     strcpy(buf, &aRes[(I64CHARSZ - 1) - j]);
 }
 
+/** Convert a signed 64-bit number to ASCII. */
 void
-printI64(char *buf,     /* char [I64CHARSZ+1]; */
-                         const U64 * pu64) {
+printI64(char *buf, /* char [I64CHARSZ+1]; */
+         const U64 * pu64)
+{
     U64             u64a;
-    U64             u64b;
-
-    char            aRes[I64CHARSZ + 1];
-    unsigned int    u;
-    int             j, sign = 0;
 
     if (pu64->high & 0x80000000) {
-        u64a.high = ~pu64->high;
-        u64a.low = ~pu64->low;
-        sign = 1;
+        u64a.high = (uint32_t) ~pu64->high;
+        u64a.low = (uint32_t) ~pu64->low;
         incrByU32(&u64a, 1);    /* bit invert and incr by 1 to print 2s complement */
+        buf[0] = '-';
+        printU64(buf + 1, &u64a);
     } else {
-        u64a.high = pu64->high;
-        u64a.low = pu64->low;
-    }
-
-    aRes[I64CHARSZ] = 0;
-    for (j = 0; j < I64CHARSZ; j++) {
-        divBy10(u64a, &u64b, &u);
-        aRes[(I64CHARSZ - 1) - j] = (char) ('0' + u);
-        u64a.high = u64b.high;
-        u64a.low = u64b.low;
-        if (isZeroU64(&u64a))
-            break;
+        printU64(buf, pu64);
     }
-    if (sign == 1) {
-        aRes[(I64CHARSZ - 1) - j - 1] = '-';
-        strcpy(buf, &aRes[(I64CHARSZ - 1) - j - 1]);
-        return;
-    }
-    strcpy(buf, &aRes[(I64CHARSZ - 1) - j]);
 }
 
+/** Convert a signed 64-bit integer from ASCII to U64. */
 int
 read64(U64 * i64, const char *str)
 {
@@ -515,75 +446,14 @@ read64(U64 * i64, const char *str)
         ok = 1;
         u = *str - '0';
         multBy10(*i64, &i64p);
-        memcpy(i64, &i64p, sizeof(i64p));
+        *i64 = i64p;
         incrByU16(i64, u);
         str++;
     }
     if (sign) {
-        i64->high = ~i64->high;
-        i64->low = ~i64->low;
+        i64->high = (uint32_t) ~i64->high;
+        i64->low = (uint32_t) ~i64->low;
         incrByU16(i64, 1);
     }
     return ok;
 }
-
-
-
-
-#ifdef TESTING
-void
-main(int argc, char *argv[])
-{
-    int             i;
-    int             j;
-    int             l;
-    unsigned int    u;
-    U64             u64a;
-    U64             u64b;
-#define MXSZ 20
-    char            aRes[MXSZ + 1];
-
-
-    if (argc < 2) {
-        printf("This program takes numbers from the command line\n"
-               "and prints them out.\n" "Usage: test <unsignedInt>...\n");
-        exit(1);
-    }
-
-    aRes[MXSZ] = 0;
-
-    for (i = 1; i < argc; i++) {
-        l = strlen(argv[i]);
-        zeroU64(&u64a);
-        for (j = 0; j < l; j++) {
-            if (!isdigit(argv[i][j])) {
-                printf("Argument is not a number \"%s\"\n", argv[i]);
-                exit(1);
-            }
-            u = argv[i][j] - '0';
-            multBy10(u64a, &u64b);
-            u64a = u64b;
-            incrByU16(&u64a, u);
-        }
-
-        printf("number \"%s\" in hex is '%08x%08x'h\n",
-               argv[i], u64a.high, u64a.low);
-
-        printf("number is \"%s\"\n", printU64(&u64a));
-        for (j = 0; j < MXSZ; j++) {
-            divBy10(u64a, &u64b, &u);
-            aRes[(MXSZ - 1) - j] = (char) ('0' + u);
-            u64a = u64b;
-            if (isZeroU64(&u64a))
-                break;
-        }
-
-        printf("number is \"%s\"\n", &aRes[(MXSZ - 1) - j]);
-    }
-    exit(0);
-}                               /* main */
-#endif                          /* TESTING */
-
-/*
- * file: test.c 
- */

commit bdbc1b14311cebb99a55c318c112cb9d7950ee0f
Author: Bart Van Assche <bvassche@users.sourceforge.net>
Date:   Mon Nov 15 14:15:48 2010 +0000

    CHANGES: snmplib: Fixed bugs in asn_parse_unsigned_int64(), asn_build_unsigned_int64(), asn_parse_signed_int64() and asn_build_signed_int64(). Most but not all of these bugs were specific to 64-bit systems. Fixes bug #3093199.
    
    
    git-svn-id: file:///home/hardaker/lib/sf-bkups/net-snmp-convert-svnrepo/branches/V5-6-patches@19672 06827809-a52a-0410-b366-d66718629ded

diff --git a/snmplib/asn1.c b/snmplib/asn1.c
index 10f7cae..030fa63 100644
--- a/snmplib/asn1.c
+++ b/snmplib/asn1.c
@@ -208,16 +208,14 @@ SOFTWARE.
 #  define CHECK_OVERFLOW_S(x,y)
 #  define CHECK_OVERFLOW_U(x,y)
 #else
-#  define CHECK_OVERFLOW_S(x,y) do { int trunc = 0;                     \
+#  define CHECK_OVERFLOW_S(x,y) do {                                    \
         if (x > INT32_MAX) {                                            \
-            trunc = 1;                                                  \
+            DEBUGMSG(("asn","truncating signed value %ld to 32 bits (%d)\n",(long)(x),y)); \
             x &= 0xffffffff;                                            \
         } else if (x < INT32_MIN) {                                     \
-            trunc = 1;                                                  \
+            DEBUGMSG(("asn","truncating signed value %ld to 32 bits (%d)\n",(long)(x),y)); \
             x = 0 - (x & 0xffffffff);                                   \
         }                                                               \
-        if (trunc)                                                      \
-            DEBUGMSG(("asn","truncating signed value to 32 bits (%d)\n",y)); \
     } while(0)
 
 #  define CHECK_OVERFLOW_U(x,y) do {                                    \
@@ -1878,13 +1876,8 @@ asn_parse_unsigned_int64(u_char * data,
         return NULL;
     }
     *datalength -= (int) asn_length + (bufp - data);
-    if (*bufp & 0x80) {
-        low = 0xFFFFFF;     /* first byte bit 1 means start the data with 1s */
-        high = 0xFFFFFF;
-    }
-
     while (asn_length--) {
-        high = ((0x00FFFFFF & high) << 8) | ((low & 0xFF000000) >> 24);
+        high = ((0x00FFFFFF & high) << 8) | ((low & 0xFF000000U) >> 24);
         low = ((low & 0x00FFFFFF) << 8) | *bufp++;
     }
 
@@ -1897,7 +1890,7 @@ asn_parse_unsigned_int64(u_char * data,
     DEBUGIF("dumpv_recv") {
         char            i64buf[I64CHARSZ + 1];
         printU64(i64buf, cp);
-        DEBUGMSG(("dumpv_recv", "Counter64: %s", i64buf));
+        DEBUGMSG(("dumpv_recv", "Counter64: %s\n", i64buf));
     }
 
     return bufp;
@@ -1955,11 +1948,8 @@ asn_build_unsigned_int64(u_char * data,
     CHECK_OVERFLOW_U(high,7);
     CHECK_OVERFLOW_U(low,7);
 
-    mask = ((u_long) 0xFF) << (8 * (sizeof(long) - 1));
-    /*
-     * mask is 0xFF000000 on a big-endian machine 
-     */
-    if ((u_char) ((high & mask) >> (8 * (sizeof(long) - 1))) & 0x80) {
+    mask = 0xff000000U;
+    if (high & 0x80000000U) {
         /*
          * if MSB is set 
          */
@@ -1972,16 +1962,12 @@ asn_build_unsigned_int64(u_char * data,
          * There should be no sequence of 9 consecutive 1's or 0's at the most
          * significant end of the integer.
          */
-        mask2 = ((u_long) 0x1FF) << ((8 * (sizeof(long) - 1)) - 1);
-        /*
-         * mask2 is 0xFF800000 on a big-endian machine 
-         */
+        mask2 = 0xff800000U;
         while ((((high & mask2) == 0) || ((high & mask2) == mask2))
                && intsize > 1) {
             intsize--;
-            high = (high << 8)
-                | ((low & mask) >> (8 * (sizeof(long) - 1)));
-            low <<= 8;
+            high = ((high & 0x00ffffffu) << 8) | ((low & mask) >> 24);
+            low = (low & 0x00ffffffu) << 8;
         }
     }
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
@@ -2046,10 +2032,9 @@ asn_build_unsigned_int64(u_char * data,
         intsize--;
     }
     while (intsize--) {
-        *data++ = (u_char) ((high & mask) >> (8 * (sizeof(long) - 1)));
-        high = (high << 8)
-            | ((low & mask) >> (8 * (sizeof(long) - 1)));
-        low <<= 8;
+        *data++ = (u_char) (high >> 24);
+        high = ((high & 0x00ffffff) << 8) | ((low & mask) >> 24);
+        low = (low & 0x00ffffff) << 8;
 
     }
     DEBUGDUMPSETUP("send", initdatap, data - initdatap);
@@ -2144,12 +2129,12 @@ asn_parse_signed_int64(u_char * data,
     }
     *datalength -= (int) asn_length + (bufp - data);
     if (*bufp & 0x80) {
-        low = 0xFFFFFF;     /* first byte bit 1 means start the data with 1s */
+        low = 0xFFFFFFFFU;   /* first byte bit 1 means start the data with 1s */
         high = 0xFFFFFF;
     }
 
     while (asn_length--) {
-        high = ((0x00FFFFFF & high) << 8) | ((low & 0xFF000000) >> 24);
+        high = ((0x00FFFFFF & high) << 8) | ((low & 0xFF000000U) >> 24);
         low = ((low & 0x00FFFFFF) << 8) | *bufp++;
     }
 
@@ -2162,7 +2147,7 @@ asn_parse_signed_int64(u_char * data,
     DEBUGIF("dumpv_recv") {
         char            i64buf[I64CHARSZ + 1];
         printI64(i64buf, cp);
-        DEBUGMSG(("dumpv_recv", "Integer64: %s", i64buf));
+        DEBUGMSG(("dumpv_recv", "Integer64: %s\n", i64buf));
     }
 
     return bufp;
@@ -2201,9 +2186,9 @@ asn_build_signed_int64(u_char * data,
      * ASN.1 integer ::= 0x02 asnlength byte {byte}*
      */
 
-    struct counter64 c64;
     register u_int  mask, mask2;
-    u_long          low, high;
+    u_long          low;
+    long            high; /* MUST be signed because of CHECK_OVERFLOW_S(). */
     size_t          intsize;
 #ifndef NETSNMP_NO_DEBUGGING
     u_char         *initdatap = data;
@@ -2215,9 +2200,8 @@ asn_build_signed_int64(u_char * data,
         return NULL;
     }
     intsize = 8;
-    memcpy(&c64, cp, sizeof(struct counter64)); /* we're may modify it */
-    low = c64.low;
-    high = c64.high;
+    low = cp->low;
+    high = cp->high; /* unsigned to signed conversion */
 
     CHECK_OVERFLOW_S(high,9);
     CHECK_OVERFLOW_U(low,9);
@@ -2228,17 +2212,13 @@ asn_build_signed_int64(u_char * data,
      * consecutive 1's or 0's at the most significant end of the
      * integer.
      */
-    mask = ((u_int) 0xFF) << (8 * (sizeof(u_int) - 1));
-    mask2 = ((u_int) 0x1FF) << ((8 * (sizeof(u_int) - 1)) - 1);
-    /*
-     * mask is 0xFF800000 on a big-endian machine 
-     */
+    mask = 0xFF000000U;
+    mask2 = 0xFF800000U;
     while ((((high & mask2) == 0) || ((high & mask2) == mask2))
            && intsize > 1) {
         intsize--;
-        high = (high << 8)
-            | ((low & mask) >> (8 * (sizeof(u_int) - 1)));
-        low <<= 8;
+        high = ((high & 0x00ffffff) << 8) | ((low & mask) >> 24);
+        low = (low & 0x00ffffff) << 8;
     }
     /*
      * until a real int64 gets incorperated into SNMP, we are going to
@@ -2257,16 +2237,15 @@ asn_build_signed_int64(u_char * data,
     *datalength -= (3 + intsize);
 
     while (intsize--) {
-        *data++ = (u_char) ((high & mask) >> (8 * (sizeof(u_int) - 1)));
-        high = (high << 8)
-            | ((low & mask) >> (8 * (sizeof(u_int) - 1)));
-        low <<= 8;
+        *data++ = (u_char) (high >> 24);
+        high = ((high & 0x00ffffff) << 8) | ((low & mask) >> 24);
+        low = (low & 0x00ffffff) << 8;
     }
     DEBUGDUMPSETUP("send", initdatap, data - initdatap);
     DEBUGIF("dumpv_send") {
         char            i64buf[I64CHARSZ + 1];
         printU64(i64buf, cp);
-        DEBUGMSG(("dumpv_send", "%s", i64buf));
+        DEBUGMSG(("dumpv_send", "%s\n", i64buf));
     }
     return data;
 }
@@ -2616,7 +2595,7 @@ asn_build_double(u_char * data,
 
     data += doublesize;
     DEBUGDUMPSETUP("send", initdatap, data - initdatap);
-    DEBUGMSG(("dumpv_send", "  Opaque double: %f", *doublep));
+    DEBUGMSG(("dumpv_send", "  Opaque double: %f\n", *doublep));
     return data;
 }
 
commit 2e1c8075698b8066c87353035f6aaacb1d61e830
Author: Jan Safranek <jsafranek@users.sourceforge.net>
Date:   Fri Feb 27 12:53:15 2015 +0100

    Removed superflous overflow check.
    
    Both high and low are 32-bit, they can't be higher than 2147483647 / lower than -2147483648.

diff --git a/snmplib/asn1.c b/snmplib/asn1.c
index f9632ef..b276e76 100644
--- a/snmplib/asn1.c
+++ b/snmplib/asn1.c
@@ -3477,9 +3477,6 @@ asn_realloc_rbuild_signed_int64(u_char ** pkt, size_t * pkt_len,
         return 0;
     }
 
-    CHECK_OVERFLOW_S(high,14);
-    CHECK_OVERFLOW_U(low,14);
-
     /*
      * Encode the low 4 bytes first.  
      */
