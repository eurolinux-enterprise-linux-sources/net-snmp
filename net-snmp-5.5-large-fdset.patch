1261727 - net-snmp segfault in netsnmp_copy_fd_set_to_large_fd_set

Backported from direct copy of large_fd_set.h and large_fd_set.c (too
many patches to list) + snmpd patch:

commit a6967c9b02ef56a52f74fde705046c6affbb158c
Author: Bart Van Assche <bvassche@users.sourceforge.net>
Date:   Thu Mar 10 19:48:43 2011 +0000

    CHANGES: snmpd: PATCH: 3203806: Avoid that the main agent processing loop - when using more than FD_SETSIZE file descriptors - can cause memory corruption by invoking select().

diff -up net-snmp-5.5/agent/snmpd.c.large-fdset net-snmp-5.5/agent/snmpd.c
--- net-snmp-5.5/agent/snmpd.c.large-fdset	2016-01-20 09:15:29.901984707 +0100
+++ net-snmp-5.5/agent/snmpd.c	2016-01-20 09:15:29.926984750 +0100
@@ -1186,7 +1186,7 @@ receive(void)
                     numfds, tvp));
         if(tvp)
             DEBUGMSGTL(("timer", "tvp %ld.%ld\n", tvp->tv_sec, tvp->tv_usec));
-        count = select(numfds, readfds.lfs_setptr, writefds.lfs_setptr, exceptfds.lfs_setptr, tvp);
+        count = netsnmp_large_fd_set_select(numfds, &readfds, &writefds, &exceptfds, tvp);
         DEBUGMSGTL(("snmpd/select", "returned, count = %d\n", count));
 
         if (count > 0) {
diff -up net-snmp-5.5/include/net-snmp/library/large_fd_set.h.large-fdset net-snmp-5.5/include/net-snmp/library/large_fd_set.h
--- net-snmp-5.5/include/net-snmp/library/large_fd_set.h.large-fdset	2016-01-20 09:15:29.768984478 +0100
+++ net-snmp-5.5/include/net-snmp/library/large_fd_set.h	2016-01-20 09:15:29.926984750 +0100
@@ -16,7 +16,7 @@
 #include <sys/select.h>
 #endif
 
-#if defined(HAVE_WINSOCK_H) && ! defined(_WINSOCKAPI_)
+#if defined(HAVE_WINSOCK_H) && !defined(_WINSOCKAPI_) && !defined(_WINSOCK_H)
 #error <winsock.h> or <winsock2.h> must have been included before this file.
 #endif
 
@@ -44,23 +44,31 @@ extern "C" {
 
 /**
  * Test whether set *fdset contains socket fd.
- * Do nothing if fd >= fdset->lfs_setsize.
+ * Evaluates to zero (false) if fd >= fdset->lfs_setsize.
  */
 #define NETSNMP_LARGE_FD_ISSET(fd, fdset) \
                     netsnmp_large_fd_is_set(fd, fdset)
 
-#if ! defined(cygwin) && defined(HAVE_WINSOCK_H)
+#if !defined(cygwin) && defined(HAVE_WINSOCK_H)
 
-/** Number of bytes needed to store setsize file descriptors. */
-#define NETSNMP_FD_SET_BYTES(setsize) (sizeof(fd_set) + sizeof(SOCKET) * (setsize - FD_SETSIZE))
+/**
+ * Number of bytes needed to store a number of file descriptors as a
+ * struct fd_set.
+ */
+#define NETSNMP_FD_SET_BYTES(setsize)                                   \
+    (sizeof(fd_set) + ((setsize) > FD_SETSIZE ?                         \
+                       ((setsize) - FD_SETSIZE) * sizeof(SOCKET) : 0))
 
 /** Remove all sockets from the set *fdset. */
 #define NETSNMP_LARGE_FD_ZERO(fdset) \
     do { (fdset)->lfs_setptr->fd_count = 0; } while(0)
 
 
+NETSNMP_IMPORT
 void   netsnmp_large_fd_setfd( SOCKET fd, netsnmp_large_fd_set *fdset);
+NETSNMP_IMPORT
 void   netsnmp_large_fd_clr(   SOCKET fd, netsnmp_large_fd_set *fdset);
+NETSNMP_IMPORT
 int    netsnmp_large_fd_is_set(SOCKET fd, netsnmp_large_fd_set *fdset);
 
 #else
@@ -73,26 +81,28 @@ int    netsnmp_large_fd_is_set(SOCKET fd
  */
 #define NETSNMP_FD_MASK_SIZE sizeof(((fd_set*)0)->fds_bits[0])
 
-/** Number of bits in one element of the fd_set::fds_bits array. */
+/** Number of bits in one element of the fd_set.fds_bits array. */
 #define NETSNMP_BITS_PER_FD_MASK (8 * NETSNMP_FD_MASK_SIZE)
 
 /** Number of elements needed for the fds_bits array. */
 #define NETSNMP_FD_SET_ELEM_COUNT(setsize) \
     (setsize + NETSNMP_BITS_PER_FD_MASK - 1) / NETSNMP_BITS_PER_FD_MASK
 
-/** Number of bytes needed to store setsize file descriptors. */
-#define NETSNMP_FD_SET_BYTES(setsize) \
-    (NETSNMP_FD_SET_ELEM_COUNT(setsize) * NETSNMP_FD_MASK_SIZE)
+/**
+ * Number of bytes needed to store a number of file descriptors as a
+ * struct fd_set.
+ */
+#define NETSNMP_FD_SET_BYTES(setsize)                                    \
+    (sizeof(fd_set) + ((setsize) > FD_SETSIZE ?                          \
+                       NETSNMP_FD_SET_ELEM_COUNT((setsize) - FD_SETSIZE) \
+                       * NETSNMP_FD_MASK_SIZE : 0))
 
 /** Remove all file descriptors from the set *fdset. */
-#define NETSNMP_LARGE_FD_ZERO(fdset)                       \
-  do {                                                     \
-    int __i;                                               \
-    fd_set *__arr = &(fdset)->lfs_set;                     \
-    __i = NETSNMP_FD_SET_ELEM_COUNT((fdset)->lfs_setsize); \
-    for ( ; __i > 0; __i--)                                \
-      __arr->fds_bits[__i - 1] = 0;                        \
-  } while (0)
+#define NETSNMP_LARGE_FD_ZERO(fdset)                            \
+    do {                                                        \
+        memset((fdset)->lfs_setptr, 0,                          \
+               NETSNMP_FD_SET_BYTES((fdset)->lfs_setsize));     \
+    } while (0)
 
 
 void   netsnmp_large_fd_setfd( int fd, netsnmp_large_fd_set *fdset);
@@ -109,15 +119,33 @@ int    netsnmp_large_fd_is_set(int fd, n
  * The file descriptor set must be initialized separately, e.g. via
  * NETSNMP_LARGE_FD_CLR().
  */
+NETSNMP_IMPORT
 void   netsnmp_large_fd_set_init(   netsnmp_large_fd_set *fdset, int setsize);
 
 /**
  * Modify the size of a file descriptor set and preserve the first
  * min(fdset->lfs_setsize, setsize) file descriptors.
+ *
+ * Returns 1 upon success or 0 if memory allocation failed.
+ */
+int    netsnmp_large_fd_set_resize( netsnmp_large_fd_set *fdset, int setsize);
+
+/**
+ * Synchronous I/O multiplexing for large file descriptor sets.
+ *
+ * On POSIX systems, any file descriptor set with size below numfds will be
+ * resized before invoking select().
+ *
+ * @see See also select(2) for more information.
  */
-void   netsnmp_large_fd_set_resize( netsnmp_large_fd_set *fdset, int setsize);
+NETSNMP_IMPORT
+int    netsnmp_large_fd_set_select(int numfds, netsnmp_large_fd_set *readfds,
+			    netsnmp_large_fd_set *writefds,
+			    netsnmp_large_fd_set *exceptfds,
+			    struct timeval *timeout);
 
 /** Deallocate the memory allocated by netsnmp_large_fd_set_init. */
+NETSNMP_IMPORT
 void   netsnmp_large_fd_set_cleanup(netsnmp_large_fd_set *fdset);
 
 /**
diff -up net-snmp-5.5/snmplib/large_fd_set.c.large-fdset net-snmp-5.5/snmplib/large_fd_set.c
--- net-snmp-5.5/snmplib/large_fd_set.c.large-fdset	2009-04-23 10:19:55.000000000 +0200
+++ net-snmp-5.5/snmplib/large_fd_set.c	2016-01-18 12:47:14.000000000 +0100
@@ -8,20 +8,22 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
+#include <string.h> /* memset(), which is invoked by FD_ZERO() */
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
-#ifdef HAVE_WINSOCK_H
-#include <winsock.h>
-#endif
-
+#include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/large_fd_set.h>
 
 
-#if ! defined(cygwin) && defined(HAVE_WINSOCK_H)
+#if !defined(cygwin) && defined(HAVE_WINSOCK_H)
+
+#define LFD_SET(n, p)    FD_SET(n, p)
+#define LFD_CLR(n, p)    FD_CLR(n, p)
+#define LFD_ISSET(n, p)  FD_ISSET(n, p)
 
 void
 netsnmp_large_fd_setfd(SOCKET fd, netsnmp_large_fd_set * fdset)
@@ -30,18 +32,18 @@ netsnmp_large_fd_setfd(SOCKET fd, netsnm
 
     netsnmp_assert(fd != INVALID_SOCKET);
 
-    if (fdset->lfs_set.fd_count == fdset->lfs_setsize)
+    if (fdset->lfs_setptr->fd_count == fdset->lfs_setsize)
         netsnmp_large_fd_set_resize(fdset, 2 * (fdset->lfs_setsize + 1));
 
-    for (i = 0; i < fdset->lfs_set.fd_count; i++) {
-        if (fdset->lfs_set.fd_array[i] == (SOCKET) (fd))
+    for (i = 0; i < fdset->lfs_setptr->fd_count; i++) {
+        if (fdset->lfs_setptr->fd_array[i] == fd)
             break;
     }
 
-    if (i == fdset->lfs_set.fd_count
-        && fdset->lfs_set.fd_count < fdset->lfs_setsize) {
-        fdset->lfs_set.fd_count++;
-        fdset->lfs_set.fd_array[i] = (fd);
+    if (i == fdset->lfs_setptr->fd_count &&
+        fdset->lfs_setptr->fd_count < fdset->lfs_setsize) {
+        fdset->lfs_setptr->fd_count++;
+        fdset->lfs_setptr->fd_array[i] = fd;
     }
 }
 
@@ -52,14 +54,14 @@ netsnmp_large_fd_clr(SOCKET fd, netsnmp_
 
     netsnmp_assert(fd != INVALID_SOCKET);
 
-    for (i = 0; i < fdset->lfs_set.fd_count; i++) {
-        if (fdset->lfs_set.fd_array[i] == (fd)) {
-            while (i < fdset->lfs_set.fd_count - 1) {
-                fdset->lfs_set.fd_array[i] =
-                    fdset->lfs_set.fd_array[i + 1];
+    for (i = 0; i < fdset->lfs_setptr->fd_count; i++) {
+        if (fdset->lfs_setptr->fd_array[i] == fd) {
+            while (i < fdset->lfs_setptr->fd_count - 1) {
+                fdset->lfs_setptr->fd_array[i] =
+                    fdset->lfs_setptr->fd_array[i + 1];
                 i++;
             }
-            fdset->lfs_set.fd_count--;
+            fdset->lfs_setptr->fd_count--;
             break;
         }
     }
@@ -72,8 +74,8 @@ netsnmp_large_fd_is_set(SOCKET fd, netsn
 
     netsnmp_assert(fd != INVALID_SOCKET);
 
-    for (i = 0; i < fdset->lfs_set.fd_count; i++) {
-        if (fdset->lfs_set.fd_array[i] == fd)
+    for (i = 0; i < fdset->lfs_setptr->fd_count; i++) {
+        if (fdset->lfs_setptr->fd_array[i] == fd)
             return 1;
     }
     return 0;
@@ -81,15 +83,52 @@ netsnmp_large_fd_is_set(SOCKET fd, netsn
 
 #else
 
+/*
+ * Recent versions of glibc trigger abort() if FD_SET(), FD_CLR() or
+ * FD_ISSET() is invoked with n >= FD_SETSIZE. Hence these replacement
+ * functions. However, since NFDBITS != 8 * sizeof(fd_set.fds_bits[0]) for at
+ * least HP-UX on ia64 and since that combination uses big endian, use the
+ * macros from <sys/select.h> on such systems.
+ */
+NETSNMP_STATIC_INLINE void LFD_SET(unsigned n, fd_set *p)
+{
+    enum { nfdbits = 8 * sizeof(p->fds_bits[0]) };
+
+    if (nfdbits == NFDBITS)
+        p->fds_bits[n / nfdbits] |= (1ULL << (n % nfdbits));
+    else
+        FD_SET(n, p);
+}
+
+NETSNMP_STATIC_INLINE void LFD_CLR(unsigned n, fd_set *p)
+{
+    enum { nfdbits = 8 * sizeof(p->fds_bits[0]) };
+
+    if (nfdbits == NFDBITS)
+        p->fds_bits[n / nfdbits] &= ~(1ULL << (n % nfdbits));
+    else
+        FD_CLR(n, p);
+}
+
+NETSNMP_STATIC_INLINE unsigned LFD_ISSET(unsigned n, const fd_set *p)
+{
+    enum { nfdbits = 8 * sizeof(p->fds_bits[0]) };
+
+    if (nfdbits == NFDBITS)
+        return (p->fds_bits[n / nfdbits] & (1ULL << (n % nfdbits))) != 0;
+    else
+        return FD_ISSET(n, p) != 0;
+}
+
 void
 netsnmp_large_fd_setfd(int fd, netsnmp_large_fd_set * fdset)
 {
     netsnmp_assert(fd >= 0);
 
-    if (fd >= fdset->lfs_setsize)
+    while (fd >= (int)fdset->lfs_setsize)
         netsnmp_large_fd_set_resize(fdset, 2 * (fdset->lfs_setsize + 1));
 
-    FD_SET(fd, fdset->lfs_setptr);
+    LFD_SET(fd, fdset->lfs_setptr);
 }
 
 void
@@ -97,8 +136,8 @@ netsnmp_large_fd_clr(int fd, netsnmp_lar
 {
     netsnmp_assert(fd >= 0);
 
-    if (fd < fdset->lfs_setsize)
-        FD_CLR(fd, fdset->lfs_setptr);
+    if ((unsigned)fd < fdset->lfs_setsize)
+        LFD_CLR(fd, fdset->lfs_setptr);
 }
 
 int
@@ -106,7 +145,8 @@ netsnmp_large_fd_is_set(int fd, netsnmp_
 {
     netsnmp_assert(fd >= 0);
 
-    return fd < fdset->lfs_setsize && FD_ISSET(fd, fdset->lfs_setptr);
+    return ((unsigned)fd < fdset->lfs_setsize &&
+            LFD_ISSET(fd, fdset->lfs_setptr));
 }
 
 #endif
@@ -115,21 +155,54 @@ void
 netsnmp_large_fd_set_init(netsnmp_large_fd_set * fdset, int setsize)
 {
     fdset->lfs_setsize = 0;
-    fdset->lfs_setptr  = 0;
+    fdset->lfs_setptr  = NULL;
+#if !defined(cygwin) && defined(HAVE_WINSOCK_H)
+    fdset->lfs_set.fd_count = 0;
+#endif
     netsnmp_large_fd_set_resize(fdset, setsize);
 }
 
-void
+int
+netsnmp_large_fd_set_select(int numfds, netsnmp_large_fd_set *readfds,
+                     netsnmp_large_fd_set *writefds,
+                     netsnmp_large_fd_set *exceptfds,
+                     struct timeval *timeout)
+{
+#if defined(cygwin) || !defined(HAVE_WINSOCK_H)
+    /* Bit-set representation: make sure all fds have at least size 'numfds'. */
+    if (readfds && readfds->lfs_setsize < numfds)
+        netsnmp_large_fd_set_resize(readfds, numfds);
+    if (writefds && writefds->lfs_setsize < numfds)
+        netsnmp_large_fd_set_resize(writefds, numfds);
+    if (exceptfds && exceptfds->lfs_setsize < numfds)
+        netsnmp_large_fd_set_resize(exceptfds, numfds);
+#else
+    /* Array representation: no resizing is necessary. */
+#endif
+
+    return select(numfds, (readfds) ? readfds->lfs_setptr : NULL,
+                  (writefds) ? writefds->lfs_setptr : NULL,
+                  (exceptfds) ? exceptfds->lfs_setptr : NULL, timeout);
+}
+
+int
 netsnmp_large_fd_set_resize(netsnmp_large_fd_set * fdset, int setsize)
 {
     int             fd_set_bytes;
 
+    if (fdset->lfs_setsize == setsize)
+        goto success;
+
     if (setsize > FD_SETSIZE) {
         fd_set_bytes = NETSNMP_FD_SET_BYTES(setsize);
-        if (fdset->lfs_setsize > FD_SETSIZE)
+        if (fdset->lfs_setsize > FD_SETSIZE) {
             fdset->lfs_setptr = realloc(fdset->lfs_setptr, fd_set_bytes);
-        else {
+            if (!fdset->lfs_setptr)
+                goto out_of_mem;
+        } else {
             fdset->lfs_setptr = malloc(fd_set_bytes);
+            if (!fdset->lfs_setptr)
+                goto out_of_mem;
             *fdset->lfs_setptr = fdset->lfs_set;
         }
     } else {
@@ -140,20 +213,36 @@ netsnmp_large_fd_set_resize(netsnmp_larg
         fdset->lfs_setptr = &fdset->lfs_set;
     }
 
-#if ! (! defined(cygwin) && defined(HAVE_WINSOCK_H))
-    {
+#if defined(cygwin) || !defined(HAVE_WINSOCK_H)
+    /*
+     * Unix: when enlarging, clear the file descriptors defined in the
+     * resized *fdset but that were not defined in the original *fdset.
+     */
+    if ( fdset->lfs_setsize == 0 && setsize == FD_SETSIZE ) {
+        /* In this case we can use the OS's FD_ZERO */
+        FD_ZERO(fdset->lfs_setptr);
+    } else {
         int             i;
 
-	/*
-	 * Unix: clear the file descriptors defined in the resized *fdset
-	 * but that were not defined in the original *fdset.
-	 */
-	for (i = fdset->lfs_setsize + 1; i < setsize; i++)
-	    FD_CLR(i, fdset->lfs_setptr);
+        for (i = fdset->lfs_setsize; i < setsize; i++)
+            LFD_CLR(i, fdset->lfs_setptr);
     }
 #endif
 
     fdset->lfs_setsize = setsize;
+#if !defined(cygwin) && defined(HAVE_WINSOCK_H)
+    if (setsize < fdset->lfs_setptr->fd_count)
+        fdset->lfs_setptr->fd_count = setsize;
+#endif
+success:
+    return 1;
+
+out_of_mem:
+    fdset->lfs_setsize = 0;
+#if !defined(cygwin) && defined(HAVE_WINSOCK_H)
+    fdset->lfs_setptr->fd_count = 0;
+#endif
+    return 0;
 }
 
 void
@@ -161,7 +250,7 @@ netsnmp_large_fd_set_cleanup(netsnmp_lar
 {
     netsnmp_large_fd_set_resize(fdset, 0);
     fdset->lfs_setsize = 0;
-    fdset->lfs_setptr  = 0;
+    fdset->lfs_setptr  = NULL;
 }
 
 void
@@ -184,13 +273,13 @@ netsnmp_copy_large_fd_set_to_fd_set(fd_s
 
     *dst = *src->lfs_setptr;
 
-#if ! (! defined(cygwin) && defined(HAVE_WINSOCK_H))
+#if !(!defined(cygwin) && defined(HAVE_WINSOCK_H))
     {
         int             i;
 
-	/* Unix: clear any file descriptors defined in *dst but not in *src. */
-	for (i = src->lfs_setsize; i < FD_SETSIZE; ++i)
-	  FD_CLR(i, dst);
+        /* Unix: clear any file descriptors defined in *dst but not in *src. */
+        for (i = src->lfs_setsize; i < FD_SETSIZE; ++i)
+            FD_CLR(i, dst);
     }
 #endif
 
