702165 - Prevent duplicate iFtable entries in net-snmp

commit 45062ea47be1cd8df4933a0de7f72f8cf9183aae
Author: Jan Safranek <jsafranek@users.sourceforge.net>
Date:   Thu Jul 28 12:24:10 2011 +0200

    CHANGES: snmpd: added 'interface_fadeout' configuration option to set lifetime of ifTable entries of removed interfaces.
    
    Previous lifetime was hardcoded 5 minutes, now it's configurable.

diff --git a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
index b7fc852..5962638 100644
--- a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
+++ b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
@@ -34,6 +34,11 @@ typedef struct cd_container_s {
  */
 static int      _first_load = 1;
 
+/*
+ * Value of interface_fadeout config option
+ */
+static int fadeout = IFTABLE_REMOVE_MISSING_AFTER;
+
 /** @ingroup interface 
  * @defgroup data_access data_access: Routines to access data
  *
@@ -55,6 +60,12 @@ static int      _first_load = 1;
  * OID: .1.3.6.1.2.1.2.2, length: 8
  */
 
+static void
+parse_interface_fadeout(const char *token, char *line)
+{
+    fadeout = atoi(line);
+}
+
 /**
  * initialization for ifTable data access
  *
@@ -75,7 +86,8 @@ ifTable_init_data(ifTable_registration * ifTable_reg)
     /*
      * TODO:303:o: Initialize ifTable data.
      */
-
+    snmpd_register_config_handler("interface_fadeout", parse_interface_fadeout, NULL,
+            "interface_fadeout seconds");
     return MFD_SUCCESS;
 }                               /* ifTable_init_data */
 
@@ -306,10 +318,10 @@ _check_interface_entry_for_updates(ifTable_rowreq_ctx * rowreq_ctx,
             time_t now = netsnmp_get_agent_uptime();
             u_long diff = (now - rowreq_ctx->data.ifLastChange) / 100;
             DEBUGMSGTL(("verbose:ifTable:access", "missing entry for %ld seconds\n", diff));
-            if (diff > IFTABLE_REMOVE_MISSING_AFTER) {
+            if (diff >= fadeout) {
                 DEBUGMSGTL(("ifTable:access", "marking missing entry %s for "
                             "removal after %d seconds\n", rowreq_ctx->data.ifName,
-                            IFTABLE_REMOVE_MISSING_AFTER));
+                            fadeout));
                 if (NULL == cdc->deleted)
                    cdc->deleted = netsnmp_container_find("ifTable_deleted:linked_list");
                 if (NULL == cdc->deleted)

commit 42b883ce18e58ca89fdfd514ec698e2f7ffd1f63
Author: Jan Safranek <jsafranek@users.sourceforge.net>
Date:   Thu Jul 28 14:32:38 2011 +0200

    Allow ifTable entries to be deleted immediately when appropriate interface
    disappears (i.e. interface_fadeout = 0 works as expected).

diff --git a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
index 5962638..10c6ee6 100644
--- a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
+++ b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
@@ -314,7 +314,8 @@ _check_interface_entry_for_updates(ifTable_rowreq_ctx * rowreq_ctx,
             rowreq_ctx->data.ifAdminStatus = IFADMINSTATUS_DOWN;
             rowreq_ctx->data.ifOperStatus = IFOPERSTATUS_DOWN;
             oper_changed = 1;
-        } else {
+        }
+        if (rowreq_ctx->known_missing) {
             time_t now = netsnmp_get_agent_uptime();
             u_long diff = (now - rowreq_ctx->data.ifLastChange) / 100;
             DEBUGMSGTL(("verbose:ifTable:access", "missing entry for %ld seconds\n", diff));

commit 406cab818926499c3121dece4377d67638894042
Author: Jan Safranek <jsafranek@users.sourceforge.net>
Date:   Thu Jul 28 14:32:57 2011 +0200

    Document the interface_fadeout option.

diff --git a/man/snmpd.conf.5.def b/man/snmpd.conf.5.def
index 82b6412..becc5f8 100644
--- a/man/snmpd.conf.5.def
+++ b/man/snmpd.conf.5.def
@@ -426,6 +426,10 @@ can be used to provide appropriate type and speed settings for
 interfaces where the agent fails to determine this information correctly.
 TYPE is a type value as given in the IANAifType-MIB,
 and can be specified numerically or by name (assuming this MIB is loaded).
+.IP "interface_fadeout TIMEOUT"
+specifies, for how long the agent keeps entries in ifTable after appropriate
+interfaces have been removed from system (typically various ppp, tap or tun
+interfaces). Timeout value is in seconds. Default value is 300 (=5 minutes).
 .SS Host Resources Group
 This requires that the agent was built with support for the
 \fIhost\fR module (which is now included as part of the default build 

commit f660b8c0d8c2707bd73142f076079c9169f35956
Author: Jan Safranek <jsafranek@users.sourceforge.net>
Date:   Thu Jul 28 14:40:27 2011 +0200

    CHANGES: snmpd: added 'interface_replace_old' option to remove old entries
    in ifTable when an interface with the same name as already exising one
    appears.
    
    E.g. remove old ppp0 interface when new ppp0 shows up.

diff --git a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
index 10c6ee6..ea351d3 100644
--- a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
+++ b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
@@ -38,6 +38,14 @@ static int      _first_load = 1;
  * Value of interface_fadeout config option
  */
 static int fadeout = IFTABLE_REMOVE_MISSING_AFTER;
+/*
+ * Value of interface_replace_old config option
+ */
+static int replace_old = 0;
+
+static void
+_delete_missing_interface(ifTable_rowreq_ctx *rowreq_ctx,
+                          netsnmp_container *container);
 
 /** @ingroup interface 
  * @defgroup data_access data_access: Routines to access data
@@ -65,6 +73,26 @@ parse_interface_fadeout(const char *token, char *line)
 {
     fadeout = atoi(line);
 }
+static void
+parse_interface_replace_old(const char *token, char *line)
+{
+    if (strcmp(line, "yes") == 0
+            || strcmp(line, "y") == 0
+            || strcmp(line, "true") == 0
+            || strcmp(line, "1") == 0) {
+        replace_old = 1;
+        return;
+    }
+    if (strcmp(line, "no") == 0
+            || strcmp(line, "n") == 0
+            || strcmp(line, "false") == 0
+            || strcmp(line, "0") == 0) {
+        replace_old = 0;
+        return;
+    }
+    snmp_log(LOG_ERR, "Invalid value of interface_replace_old parameter: '%s'\n",
+            line);
+}
 
 /**
  * initialization for ifTable data access
@@ -88,6 +116,9 @@ ifTable_init_data(ifTable_registration * ifTable_reg)
      */
     snmpd_register_config_handler("interface_fadeout", parse_interface_fadeout, NULL,
             "interface_fadeout seconds");
+    snmpd_register_config_handler("interface_replace_old",
+            parse_interface_replace_old, NULL, "interface_replace_old yes|no");
+
     return MFD_SUCCESS;
 }                               /* ifTable_init_data */
 
@@ -411,6 +442,40 @@ _check_interface_entry_for_updates(ifTable_rowreq_ctx * rowreq_ctx,
 }
 
 /**
+ * Remove all old interfaces with the same name as the newly added one.
+ */
+static void
+_check_and_replace_old(netsnmp_interface_entry *ifentry,
+                   netsnmp_container *container)
+{
+    netsnmp_iterator *it;
+    ifTable_rowreq_ctx * rowreq_ctx;
+    netsnmp_container *to_delete;
+
+    to_delete = netsnmp_container_find("ifTable_deleted:linked_list");
+    if (NULL == to_delete) {
+       snmp_log(LOG_ERR, "couldn't create container for deleted interface\n");
+       return;
+    }
+
+    it = CONTAINER_ITERATOR(container);
+    for (rowreq_ctx = ITERATOR_FIRST(it); rowreq_ctx; rowreq_ctx = ITERATOR_NEXT(it)) {
+        if (strcmp(ifentry->name, rowreq_ctx->data.ifentry->name) == 0) {
+            DEBUGMSGTL(("ifTable:access",
+                    "removing interface %ld due to new %s\n",
+                    (long) rowreq_ctx->data.ifentry->index, ifentry->name));
+            CONTAINER_INSERT(to_delete, rowreq_ctx);
+        }
+    }
+    ITERATOR_RELEASE(it);
+
+    CONTAINER_FOR_EACH(to_delete,
+                       (netsnmp_container_obj_func *) _delete_missing_interface,
+                       container);
+    CONTAINER_FREE(to_delete);
+}
+
+/**
  * add new entry
  */
 static void
@@ -428,6 +493,9 @@ _add_new_interface(netsnmp_interface_entry *ifentry,
     rowreq_ctx = ifTable_allocate_rowreq_ctx(ifentry);
     if ((NULL != rowreq_ctx) &&
         (MFD_SUCCESS == ifTable_indexes_set(rowreq_ctx, ifentry->index))) {
+        if (replace_old)
+                _check_and_replace_old(ifentry, container);
+
         CONTAINER_INSERT(container, rowreq_ctx);
         /*
          * fix this when we hit an arch that reports its own last change

commit d62a0eb9070b4d8d9fe2bcfdb4d53d37ef814f9b
Author: Jan Safranek <jsafranek@users.sourceforge.net>
Date:   Thu Jul 28 14:49:08 2011 +0200

    Document interface_replace_old option.

diff --git a/man/snmpd.conf.5.def b/man/snmpd.conf.5.def
index becc5f8..c7e4b6a 100644
--- a/man/snmpd.conf.5.def
+++ b/man/snmpd.conf.5.def
@@ -427,9 +427,17 @@ interfaces where the agent fails to determine this information correctly.
 TYPE is a type value as given in the IANAifType-MIB,
 and can be specified numerically or by name (assuming this MIB is loaded).
 .IP "interface_fadeout TIMEOUT"
-specifies, for how long the agent keeps entries in ifTable after appropriate
-interfaces have been removed from system (typically various ppp, tap or tun
-interfaces). Timeout value is in seconds. Default value is 300 (=5 minutes).
+specifies, for how long the agent keeps entries in \fCifTable\fR after
+appropriate interfaces have been removed from system (typically various ppp,
+tap or tun interfaces). Timeout value is in seconds. Default value is 300
+(=5 minutes).
+.IP "interface_replace_old yes"
+can be used to remove already existing entries in \fCifTable\fR when an
+interface with the same name appears on the system. E.g. when ppp0 interface
+is removed, it is still listed in the table for \fIinterface_fadeout\fR
+seconds. This option ensures, that the old ppp0 interface is removed even
+before the \fIinterface_fadeout\fR timeour when new ppp0 (with different
+\fCifIndex\fR) shows up.
 .SS Host Resources Group
 This requires that the agent was built with support for the
 \fIhost\fR module (which is now included as part of the default build 

commit 3458128b4a3c5971998894f9d9d8ccc6c76d3c9b
Author: Jan Safranek <jsafranek@users.sourceforge.net>
Date:   Thu Jul 28 16:16:15 2011 +0200

    Fix potential sigsegv when an ifTable entry is removed as result of both interface_replace_old and interface_fadeout at the same time.

diff --git a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
index ea351d3..b5bc3b7 100644
--- a/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
+++ b/agent/mibgroup/if-mib/ifTable/ifTable_data_access.c
@@ -639,19 +639,21 @@ ifTable_container_load(netsnmp_container *container)
                        _check_interface_entry_for_updates, &cdc);
 
     /*
-     * now add any new interfaces
-     */
-    CONTAINER_FOR_EACH(cdc.current,
-                       (netsnmp_container_obj_func *) _add_new_interface,
-                       container);
-
-    /*
      * now remove any missing interfaces
      */
-    if (NULL != cdc.deleted)
+    if (NULL != cdc.deleted) {
        CONTAINER_FOR_EACH(cdc.deleted,
                           (netsnmp_container_obj_func *) _delete_missing_interface,
                           container);
+       CONTAINER_FREE(cdc.deleted);
+    }
+
+    /*
+     * now add any new interfaces
+     */
+    CONTAINER_FOR_EACH(cdc.current,
+                       (netsnmp_container_obj_func *) _add_new_interface,
+                       container);
 
     /*
      * free the container. we've either claimed each ifentry, or released it,
